그리드 문제야 뭐 상태 후보가 12개이고 행동 후보는 4개뿐이라서 Q함수 후보는 총 12 x 4 = 48개이다. 이 정도야 Q 함수를 테이블로 관리하는데 아무 문제도 없다. 

근데 만약 체스는 어떻게 할 것인가? 체스의 보드 배열 패턴은 10<sup>123</sup>이다. 즉, 상태가 이 수만큼 존재한다는 뜻이다. 이 많은 상태를 테이블로 관리하려면 슈퍼 컴퓨터 여러대는 필요할 것이다. 더 큰 문제는 테이블으 원소 하나하나를 독립적으로 평가하고 개선해야 한다는 점이다. 

이걸 가능하게 하려면 역시 신경망으로 인한 합리적인 추론 방법이 필요할 것이다.

### 1. 신경망의 전처리
---
범주형 데이터 (옷 사이즈 S/M/L, 혈액형 A/B/O/AB) 데이터를 원 핫 벡터로 만드는것은 기본적인 상식이다. 

즉, 그리드 월드의 상태또한 원-핫 벡터로 만들어야 한다. 

``` python
def one_hot(state):
    HEIGHT, WIDTH = 3, 4
    vec = np.zeros(HEIGHT * WIDTH, dtype=np.float32) # 각 원소를 담을 벡터 준비
    
    y, x = state 
    idx = WIDTH * y + x
    vec[idx] = 1.0 # 주어진 상태만 1
    
    return vec[np.newaxis, :] # 배치 처리를 위헤ㅐ 새로운 축 추가 (batch, 12)
```

### 2. Q 함수를 표현하는 신경망
---
이전에 Q함수를 테이블 (파이썬 코드에서는 딕셔너리 defaultdict)로 구현했다. 

``` python
Q = defaultdict(lambda: 0)
state = (2, 0)
action = 0

print(Q[state, action]) # 출력 결과 0.0
```




