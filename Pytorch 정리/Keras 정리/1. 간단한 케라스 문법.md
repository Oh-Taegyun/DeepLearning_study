기본적으로 넘파이로 구동한다.

``` python
(train_images, train_labels), (test_images, test_labels) = mnist.load_data() train_images = train_images.reshape((60000, 28 * 28)) train_images = train_images.astype('float32') / 255 test_images = test_images.reshape((10000, 28 * 28)) test_images = test_images.astype('float32') / 255 network = models.Sequential() 

network.add(layers.Dense(512, activation='relu', input_shape=(28 * 28,))) network.add(layers.Dense(10, activation='softmax')) 
network.compile(optimizer='rmsprop',loss='categorical_crossentropy',metrics=                 ['accuracy']) network.fit(train_images, train_labels,                         epochs=5, batch_size=128)
```

### 1. 모델 만들기
---
``` python
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

model = Sequential()
model.add(...) # 층 추가
model.add(...) # 층 추가
model.add(...) # 층 추가

```

**Sequential()** : 케라스에서는 층을 구성하기 위해 Sequential()을 사용한다. (파이토치에 똑같은 놈이 있다는 것을 생각하자)

Sequential()을 model로 선언한 뒤에 model.add()라는 코드를 통해 층을 단계적으로 추가한다.

참고로 **summary()** 라는 메서드도 존재한다. 이 메서드는 모델의 정보를 요약해서 보여준다.
``` python
model.summary()
```

##### 1-1. Dense()
---
``` python
model = Sequential()
model.add(Dense(8, input_dim=4, activation='relu'))
model.add(Dense(1, activation='sigmoid')) # 출력층
```

완전 연결층이다. 
 - 필요 파라미터
	 - **첫번째 인자** = 출력 뉴런의 수.  
	 - **input_dim** = 입력 뉴런의 수. (입력의 차원)  
	 - **activation** = 활성화 함수.  
		- linear : 디폴트 값으로 별도 활성화 함수 없이 입력 뉴런과 가중치의 계산 결과 그대로 출력.  
		- sigmoid : 이진 분류 문제에서 출력층에 주로 사용되는 활성화 함수.  
		- softmax : 셋 이상의 선택지 중 하나를 택하는 다중 클래스 분류 문제에서 출력층에 주로 사용되는 활성화 함수.  
		- relu : 은닉층에 주로 사용되는 활성화 함수.

### 2. 컴파일
---
``` python
from tensorflow.keras.layers import SimpleRNN, Embedding, Dense
from tensorflow.keras.models import Sequential

vocab_size = 10000
embedding_dim = 32
hidden_units = 32

model = Sequential()
model.add(Embedding(vocab_size, embedding_dim))
model.add(SimpleRNN(hidden_units))
model.add(Dense(1, activation='sigmoid'))
model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['acc'])

```

말 그대로 모델 그 자체를 컴파일하는 과정이다.
 - 파라미터
	- **optimizer** = 훈련 과정을 설정하는 옵티마이저를 설정합니다.  
	- **loss** = 훈련 과정에서 사용할 손실 함수(loss function)를 설정합니다.  
	- **metrics** = 훈련을 모니터링하기 위한 지표를 선택합니다.

### 3. fit()
---
``` python
model.fit(X_train, y_train, epochs=10, batch_size=32)
```

모델을 학습하라고 지시하는 코드
- 파라미터
	- 훈련할 데이터(입력과 타킷)
	- 훈련할 에포크 횟수
	- 배치 크기
	- **validation_data(x_val, y_val)** = 검증 데이터(validation data)를 사용합니다.
